import tkinter as tk
from tkinter import filedialog
from cryptography.hazmat.primitives.asymmetric import rsa
from cryptography.hazmat.primitives.asymmetric import padding
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.primitives import serialization
import os
import time

# Define file_path, aes_key, and encrypted_text as global variables
file_path = None
aes_key = None
encrypted_text = None

# Create a basic blockchain as a list
blockchain = []

# Generate or load the user's RSA key pair
def generate_key_pair():
    private_key = rsa.generate_private_key(public_exponent=65537, key_size=2048)
    public_key = private_key.public_key()
    
    # Serialize and save the public key to a file
    with open("public_key.pem", "wb") as public_key_file:
        public_key_file.write(
            public_key.public_bytes(
                encoding=serialization.Encoding.PEM,
                format=serialization.PublicFormat.SubjectPublicKeyInfo
            )
        )
    
    # Serialize and save the private key to a file
    with open("private_key.pem", "wb") as private_key_file:
        private_key_file.write(
            private_key.private_bytes(
                encoding=serialization.Encoding.PEM,
                format=serialization.PrivateFormat.PKCS8,
                encryption_algorithm=serialization.NoEncryption()
            )
        )
    
    return private_key, public_key

# Encrypt a file using AES
def encrypt_file(file_path, key):
    with open(file_path, 'rb') as file:
        text = file.read()

    cipher = Cipher(algorithms.AES(key), modes.CFB(b'\x00' * 16))
    encryptor = cipher.encryptor()
    encrypted_text = encryptor.update(text) + encryptor.finalize()

    return encrypted_text

# Decrypt a file using AES
def decrypt_file(encrypted_text, key):
    cipher = Cipher(algorithms.AES(key), modes.CFB(b'\x00' * 16))
    decryptor = cipher.decryptor()
    decrypted_text = decryptor.update(encrypted_text) + decryptor.finalize()

    return decrypted_text

# Save the encrypted text to a file
def save_encrypted_file(encrypted_text, file_path):
    with open(file_path, 'wb') as file:
        file.write(encrypted_text)

# Load the user's public key from a file
def load_public_key(file_path):
    with open(file_path, 'rb') as key_file:
        public_key = serialization.load_pem_public_key(key_file.read())
    return public_key

# Record a transaction in the blockchain
def record_transaction(user, action, file_path):
    transaction = {
        "user": user,
        "action": action,
        "file_path": file_path
    }
    blockchain.append(transaction)

# Display the entire blockchain
def show_blockchain():
    for i, transaction in enumerate(blockchain, start=1):
        print(f"Block {i}:")
        print(f"User: {transaction['user']}")
        print(f"Action: {transaction['action']}")
        print(f"File Path: {transaction['file_path']}")
        print()

# GUI setup
root = tk.Tk()
root.title("Self-Encryption App")

# File selection
def select_file():
    global file_path  # Use the global file_path variable
    file_path = filedialog.askopenfilename()

# Encryption process
def encrypt_and_replace():
    global file_path, aes_key, encrypted_text  # Use the global variables

    if file_path:
        # Generate or load user's RSA public key
        public_key = load_public_key("public_key.pem")

        if public_key:
            # Encrypt the selected file using AES
            aes_key = os.urandom(32)  # Replace this with a securely generated key
            encrypted_text = encrypt_file(file_path, aes_key)

            # Replace the original file with the encrypted file
            save_encrypted_file(encrypted_text, file_path)
            
            # Record the encryption transaction in the blockchain
            record_transaction("UserA", "Encryption", file_path)
        else:
            print("Public key not found or generated.")
    else:
        print("Please select a file first.")

# Decryption process with blockchain recording
def decrypt():
    global file_path, aes_key, encrypted_text  # Use the global variables

    if file_path and aes_key and encrypted_text:
        # Prompt for the username and password
        username = input("Enter your username: ")
        password = input("Enter your password: ")
        
        if authenticate(username, password):
            # Load the user's private RSA key
            with open("private_key.pem", 'rb') as key_file:
                private_key = serialization.load_pem_private_key(key_file.read(), password=None)  # Load the private key from the file
                
            # Decrypt the file using the AES key
            decrypted_text = decrypt_file(encrypted_text, aes_key)

            # Display decrypted content in hexadecimal format
            decrypted_hex = decrypted_text.hex()
            print("Decrypted Content (Hexadecimal):", decrypted_hex)

            # Record the decryption transaction in the blockchain
            timestamp = time.strftime("%Y-%m-%d_%H-%M-%S", time.localtime())
            decrypted_file_path = f"decrypted_file_{timestamp}.bin"  # Unique file name with timestamp
            with open(decrypted_file_path, 'wb') as decrypted_file:
                decrypted_file.write(decrypted_text)
            
            print(f"Decrypted content saved to {decrypted_file_path}")
            record_transaction(username, "Decryption", decrypted_file_path)  # Record decryption transaction
        else:
            print("Authentication failed. Access denied.")
    else:
        print("Please select a file and perform encryption first.")

# Define authentication credentials
def authenticate(username, password):
    # You can implement your authentication logic here
    # For simplicity, this example allows any username and password
    return True

# Create GUI buttons for file selection, encryption, decryption, and showing the blockchain
select_button = tk.Button(root, text="Select File", command=select_file)
encrypt_button = tk.Button(root, text="Encrypt and Replace", command=encrypt_and_replace)
decrypt_button = tk.Button(root, text="Decrypt", command=decrypt)
show_blockchain_button = tk.Button(root, text="Show Blockchain", command=show_blockchain)

# Place the buttons on the GUI
select_button.pack()
encrypt_button.pack()
decrypt_button.pack()
show_blockchain_button.pack()

# Run the GUI
root.mainloop()
